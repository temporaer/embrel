function [x,histout,costdata] = bfgs_min2(x0,f,tol,maxit,hess0,params,nsmax)%% C. T. Kelley, July 17, 1997%% This code comes with no guarantee or warranty of any kind.%% function [x,histout] = bfgswopt(x0,f,tol,maxit,hess0)%% steepest descent/bfgs with polynomial line search% Steve Wright storage of H^-1%% if the BFGS update succeeds % backtrack on that with a polynomial line search, otherwise we use SD%% Input: x0 = initial iterate%        f = objective function,%            the calling sequence for f should be%            [fout,gout]=f(x) where fout=f(x) is a scalar%              and gout = grad f(x) is a COLUMN vector%        tol = termination criterion norm(grad) < tol%              optional, default = 1.d-6%        maxit = maximum iterations (optional) default = 20%         hess0 = (optional)%            function that computes the action of the%            initial inverse Hessian on a vector. This is optional. The%            default is H_0 = I (ie no action). The format of hess0 is%            h0v = hess0(v) is the action of H_0^{-1} on a vector v%% Output: x = solution%         histout = iteration history   %             Each row of histout is%       [norm(grad), f, num step reductions, iteration count]%         costdata = [num f, num grad, num hess] %                 (num hess=0 always, in here for compatibility with steep.m)%% At this stage all iteration parameters are hardwired in the code.%blow=.1; bhigh=.5;numf=0; numg=0; numh=0;if nargin < 4maxit=20; endif nargin < 3tol=1.d-6;enditc=1; xc=x0;clear x0;length(xc)if nargin<6  if length(xc)>1000    nsmax = 10;  else    nsmax=56; %56;  endend   debug=0;% Amir maxarm=10maxarm=10;%n=length(xc);userhess=0; if nargin == 5userhess=1;end%disp('BefFirstEval');[fc,gc]=feval(f,xc,params); numf=numf+1; numg=numg+1;%disp('AftFirstEval');ithist=zeros(maxit,3);ithist(1,1)=norm(gc); ithist(1,2) = fc; ithist(1,4)=itc-1;ithist(1,3)=0; if debug==1     ithist(itc,:)end%disp('BFA');go=zeros(n,1); alpha=zeros(nsmax,1); beta=alpha;sstore=zeros(n,nsmax); ns=0;%disp('BFB');%%	dsdp = - H_c^{-1} grad_+ if ns > 0%while(norm(gc) > tol & itc <= maxit)  print_to_log('It=%d Val=%g\n',itc,full(fc));  lambda = 1;    dsd=-gc;  dsdp=-gc;  if userhess==1 dsdp=feval(hess0,dsd); end  if (ns>1)    if userhess==1      dsdp=bfgsw(sstore,alpha,beta,ns,dsd,hess0);else%disp('BFC');      dsdp=bfgsw(sstore,alpha,beta,ns,dsd);%disp('BFD');    end  end  %  %  % compute the direction  %  if (ns==0)     dsd=-gc;    if userhess==1 dsd=feval(hess0,dsd); end  else    xi=-dsdp;    b0=-1/(y'*s);    zeta=(1-1/lambda)*s+xi;    a1=b0*b0*(zeta'*y);    a1=-b0*(1 - 1/lambda)+b0*b0*y'*xi;    a=-(a1*s+b0*xi)'*gc;    %    %		We save go=s'*g_old just so we can use it here    %		and avoid some cancellation error    %    alphatmp=a1+2*a/go;    b=-b0*go;    %    %    dsd=a*s+b*xi;  end  %  %  %  if (dsd'*gc > -1.d-6*norm(dsd)*norm(gc))    disp(' loss of descent')    [itc, dsd'*gc]    dsd=-gc;    ns=0;  end%  disp('BefFirst');  lambda=1; xt=xc+lambda*dsd; ft=feval(f,xt,params);  numf=numf+1;%  disp('AftFirst');    % Make sure ft is finite  inf_fact = 0.5;  reg_fact = 0.5;  % Downscale lambda until reach feasible point  upfact = 2;  if 0  if ft<fc    last_bst = ft;    while 1      tmplambda = lambda*upfact;      tmpxt = xc+tmplambda*dsd;%      disp('BefUp');      tmpft = feval(f,tmpxt,params);                 %      fprintf('TmpF=%g\n',tmpft);%      disp('AftUp');      if tmpft>=last_bst | lambda>=256	break;      else	fprintf(1,'UpLambda %g\n',lambda);	lambda = tmplambda;	ft = tmpft;	xt = tmpxt;      end      end      end  end  b_inf_dec = 0;  b_reg_dec = 0;  while ft>fc     if isinf(ft)      b_inf_dec = b_inf_dec+1;      lambda = lambda*inf_fact;    else      b_reg_dec=b_reg_dec+1;      lambda = lambda*reg_fact;    end    %    lambda = lambda*fact;    %         fprintf(1,'DownLambda %g\n',lambda);    xt = xc+lambda*dsd;%    disp('BefDown');    ft = feval(f,xt,params);%    disp('AftDown');  end  if b_inf_dec+b_reg_dec>0%    fprintf('Reg=%d  Inf=%d\n',b_reg_dec,b_inf_dec);  end    itc=itc+1;   s=xt-xc; y=gc; go=s'*gc;  %  disp('BefGrad');  xc=xt; [fc,gc]=feval(f,xc,params); y = gc-y; numf=numf+1; ...      numg=numg+1;%  print_to_log('Val=%g\n',fc);  %  disp('AftGrad');   %  %   restart if y'*s is not positive or we're out of room  if (y'*s <= 0) | (ns==nsmax) %    disp(' loss of positivity or storage');  %   [ns, y'*s]%    if sum(y)==0 | sum(s)==0%      break;%    end      ns=0;  else    ns=ns+1; sstore(:,ns)=s;    if(ns>1)      alpha(ns-1)=alphatmp;      beta(ns-1)=b0/(b*lambda);    end  end	    ithist(itc,1)=norm(gc); ithist(itc,2) = fc;   ithist(itc,4)=itc-1;   if debug==1    ithist(itc,:)  end  if itc>5     val_change_back = ithist(itc-5,2)-ithist(itc,2);    if abs(val_change_back) < abs(1e-9*fc)      disp('Val Thr');      break;    end%    fprintf('Change = %g Of=%g\n',val_change_back,1e-8*fc);    if lambda>1       lamfact = lambda;    else      lamfact = 1;    end    if lamfact*norm(gc)<1e-9*norm(xc)      disp('Grad thr');      break;    end  endendx=xc; histout=ithist(1:itc,:); costdata=[numf, numg, numh];if norm(gc)<tol  disp('Break on Norm');end%% bfgsw%% C. T. Kelley, Dec 20, 1996%% This code comes with no guarantee or warranty of any kind.%% This code is used in bfgswopt.m % % There is no reason to ever call this directly.%% form the product of the bfgs approximate inverse Hessian% with a vector using the Steve Wright method%function dnewt=bfgsw(sstore,alpha,beta,ns,dsd,hess0)userhess=0; if nargin==6 userhess=1; enddnewt=dsd; if userhess==1 dnewt=feval(hess0,dnewt); endif (ns<=1) return; end;dnewt=dsd; n=length(dsd);if userhess==1 dnewt=feval(hess0,dnewt); endsigma=sstore(:,1:ns-1)'*dsd; gamma1=alpha(1:ns-1).*sigma;gamma2=beta(1:ns-1).*sigma;gamma3=gamma1+beta(1:ns-1).*(sstore(:,2:ns)'*dsd);delta=gamma2(1:ns-2)+gamma3(2:ns-1);dnewt=dnewt+gamma3(1)*sstore(:,1)+gamma2(ns-1)*sstore(:,ns);if(ns <=2) return; enddnewt=dnewt+sstore(1:n,2:ns-1)*delta(1:ns-2);%